AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: "SAM template for backend and related functions"

Metadata:
  Globals:
    Function:
      Tracing: Active
    Api:
      Cors: 
        AllowMethods: "'GET,POST,PUT,PATCH,DELETE,OPTIONS'"
        AllowHeaders: "'Accept-Encoding,Content-Encoding,Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,Client-ID,key,secret,session'"
        AllowOrigin: "'*'"

Parameters:
  HOSTEDZONEID:
    Type: String
  CERTIFICATEARN:
    Type: String
  STRIPEAPIKEY:
    Type: String

Resources:

  # define api gateway
  ApiGatewayBackend:
    Type: AWS::Serverless::Api
    Properties:
      StageName: prd
      Name: get_layers_api

  ApiDomain:
    Type: AWS::ApiGateway::DomainName
    Properties:
      DomainName: !Sub "api-${AWS::Region}.easylayers.dev"
      CertificateArn:
        Ref: CERTIFICATEARN

  APIMapping:
    Type: AWS::ApiGateway::BasePathMapping
    DependsOn: ApiDomain
    Properties: 
      DomainName: !Sub "api-${AWS::Region}.easylayers.dev"
      RestApiId: !Ref ApiGatewayBackend
      Stage: prd
      # BasePath: !Ref "AWS::Region"

  Route53RecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !Sub "api-${AWS::Region}.easylayers.dev"
      Type: A
      HostedZoneId: 
        Ref: HOSTEDZONEID 
      AliasTarget:
        DNSName: !GetAtt ApiDomain.DistributionDomainName
        EvaluateTargetHealth: false
        HostedZoneId: !GetAtt ApiDomain.DistributionHostedZoneId

  # Needed layer Policy
  NeededLayerLambdaPolicy:
        Type: "AWS::IAM::ManagedPolicy"
        Properties:
            ManagedPolicyName: !Sub "needed-layers-lambda-policy-${AWS::Region}"
            Path: "/service-role/"
            PolicyDocument: !Sub |
                {
                    "Version": "2012-10-17",
                    "Statement": [
                        {
                            "Effect": "Allow",
                            "Action": [
                                "logs:CreateLogGroup",
                                "logs:CreateLogStream",
                                "logs:PutLogEvents"
                            ],
                            "Resource": "*"
                        },
                        {
                            "Action": [
                                "logs:CreateLogGroup"
                            ],
                            "Resource": "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*",
                            "Effect": "Allow"
                        },
                        {
                            "Action": [
                                "logs:CreateLogStream",
                                "logs:PutLogEvents"
                            ],
                            "Resource": [
                                "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
                            ],
                            "Effect": "Allow"
                        },
                        {
                            "Action": [
                                "lambda:ListFunctions",
                                "lambda:ListLayerVersions",
                                "lambda:ListLayers"
                            ],
                            "Resource": "*",
                            "Effect": "Allow",
                            "Sid": "VisualEditor0"
                        },
                        {
                            "Action": [
                                "lambda:GetLayerVersion",
                                "lambda:DeleteLayerVersion",
                                "lambda:AddLayerVersionPermission"
                            ],
                            "Resource": "*",
                            "Effect": "Allow",
                            "Sid": "VisualEditor1"
                        },
                        {
                            "Action": [
                                "s3:PutObject",
                                "s3:GetObjectAcl",
                                "s3:GetObject",
                                "logs:CreateLogStream",
                                "lambda:PublishLayerVersion",
                                "s3:ListBucket",
                                "logs:PutLogEvents"
                            ],
                            "Resource": [
                                "*"
                            ],
                            "Effect": "Allow",
                            "Sid": "VisualEditor2"
                        }
                    ]
                }

  # Needed layers iam role
  NeededLayersLambdaRole:
    Type: "AWS::IAM::Role"
    Properties:
        Path: "/service-role/"
        RoleName: !Sub "needed-layers-lambda-role-${AWS::Region}"
        AssumeRolePolicyDocument: !Sub |
            {
                "Version":"2012-10-17",
                "Statement":[
                    {
                      "Effect": "Allow",
                      "Principal": {
                          "Service": "lambda.amazonaws.com"
                      },
                      "Action": "sts:AssumeRole"
                  }
                ]
            }
        MaxSessionDuration: 3600
        ManagedPolicyArns:
          - !Ref NeededLayerLambdaPolicy


  # create all the needed layers
  CreateNeededLayer310arm:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import sys 
          import os
          import shutil
          import boto3
          from subprocess import run,CalledProcessError
          import urllib.request
          from zipfile import ZipFile
          import platform
          import cfnresponse

          try:
              from packaging.version import parse
          except ImportError:
              from pip._vendor.packaging.version import parse
              
          S3 = boto3.resource('s3')
          Bucket = S3.Bucket('easy-layers-dev-${AWS::Region}')
          Lambda = boto3.client('lambda')

          def lambda_handler(event, context):
              # Test Access permision to S3
              try:
                  Bucket.objects.limit(count=1)
              except Exception:
                  return "This function has no access to this bucker or its not exists, please validate"
              # Test access to lambda resources
              try:
                  Lambda.list_functions()
              except Exception:
                  return "This function has no access to Lambda resources, please validate"
              # Create a new layer
              result = {} 
              for library in ['jsonschema','requests','stripe']:
                  new_library_arn = create_new(library , Bucket, Lambda)
                  result[library] = new_library_arn
                  print(new_library_arn)
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, result)
              return result

          def create_new(library, Bucket, Lambda):
              # Extract parameters from API
              library_version = None

              machine = 'arm64' if platform.machine() == 'aarch64' else platform.machine()
              run_time = 'python' + '.'.join(sys.version.split(' ')[0].split('.')[0:2])
              run_time_dash = 'py' + ''.join(sys.version.split(' ')[0].split('.')[0:2]) 

              
              # get the library name and if it has versions make it like such requests==2.28.1
              library_install = library if library_version is None else library + "==" + library_version
              # Check if the package  exists 
              max_version = 'x'
              max_version_and_lib = library + "==" + str(max_version)

              # make the layer name readable and consistent of an ARN and for S3
              library_and_version=None
              if library_version is None:
                  library_and_version=max_version_and_lib.replace('==','-')
              else:
                  library_and_version=library_install.replace('==','-')
              
              layer_name =  (library_and_version + '-' + run_time_dash + '-' + machine[0:3]).replace('.','-')

              # # Then check if Layer exists in the account already
              layer_exists = check_if_layer_exists(layer_name)
              # if layer exists return the Layer ARN
              if layer_exists:
                  return layer_exists
              # if layer doesn't exist the run the process of making a new layer
              # Make sure the dir is empty
              run(["rm" , "-rf", "/tmp/*"])
              # Prepare the dir 
              run(["mkdir" ,"/tmp/python" ])
              # Install the new libraries
              outcome = run(["python" , "-m" , "pip" , "install" , library_install  , "-t", "/tmp/python"], check=False, capture_output=True,text=True)
              # print logs
              print(f"returncode = {outcome.returncode}")
              print(f"output: \n {outcome.stdout}")
              
              # Calculate layer limit
              dir_size = run(["du" , "-sh", "/tmp/python"], capture_output=True, text=True)
              dir_size = dir_size.stdout.split()[0]
              dir_size = dir_size.split("M")[0]
              dir_size = dir_size if len(dir_size.split("K"))<2 else float(dir_size.split("K")[0])/1000
              
              if int(float(dir_size)) >= 250:
                  raise ValueError( "Couldn't run. Layer size is over limit.") 

              # Zip the installed libraries
              zip_directory("/tmp/python/" , "/tmp/python.zip")

              # Upload the library into S3
              try:
                  Bucket.upload_file("/tmp/python.zip", "layers_repository/" + layer_name + ".zip")
              except Exception as e:
                  raise e
              # Create a new layer
              try:
                  new_layer = Lambda.publish_layer_version(LayerName= layer_name,
                                                              Content= {
                                                                  'S3Bucket': 'easy-layers-dev-${AWS::Region}',
                                                                  'S3Key':  "layers_repository/" + layer_name + ".zip"},
                                                              CompatibleRuntimes=[run_time],
                                                              CompatibleArchitectures=[machine])
              except Exception as e:
                  raise e
              # Return layer version ARN
              return new_layer["LayerVersionArn"]

          def check_if_layer_exists(layer_name):
              try:
                  list_layer_version = Lambda.list_layer_versions(LayerName=layer_name)["LayerVersions"][0]["LayerVersionArn"]
                  return list_layer_version
              except Exception:
                  pass
              
          def zip_directory(folder_path, zip_path):
              with ZipFile(zip_path, mode='w') as zipf:
                  len_dir_path = len(folder_path)
                  for root, _, files in os.walk(folder_path):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, 'python/'+file_path[len_dir_path:])
      FunctionName: create_needed_layers_310arm
      Handler: index.lambda_handler
      Runtime: python3.10
      Architectures: 
        - arm64
      Description: Creates Needed Layers For Python 3.10 ARM
      Timeout: 300
      Role: !GetAtt NeededLayersLambdaRole.Arn

  CreateNeededLayer310x86:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import sys 
          import os
          import shutil
          import boto3
          from subprocess import run,CalledProcessError
          import urllib.request
          from zipfile import ZipFile
          import platform
          import cfnresponse

          try:
              from packaging.version import parse
          except ImportError:
              from pip._vendor.packaging.version import parse
              
          S3 = boto3.resource('s3')
          Bucket = S3.Bucket('easy-layers-dev-${AWS::Region}')
          Lambda = boto3.client('lambda')

          def lambda_handler(event, context):
              # Test Access permision to S3
              try:
                  Bucket.objects.limit(count=1)
              except Exception:
                  return "This function has no access to this bucker or its not exists, please validate"
              # Test access to lambda resources
              try:
                  Lambda.list_functions()
              except Exception:
                  return "This function has no access to Lambda resources, please validate"
              # Create a new layer
              result = {} 
              for library in ['jsonschema','requests','stripe']:
                  new_library_arn = create_new(library , Bucket, Lambda)
                  result[library] = new_library_arn
                  print(new_library_arn)
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, result)
              return result

          def create_new(library, Bucket, Lambda):
              # Extract parameters from API
              library_version = None

              machine = 'arm64' if platform.machine() == 'aarch64' else platform.machine()
              run_time = 'python' + '.'.join(sys.version.split(' ')[0].split('.')[0:2])
              run_time_dash = 'py' + ''.join(sys.version.split(' ')[0].split('.')[0:2]) 

              
              # get the library name and if it has versions make it like such requests==2.28.1
              library_install = library if library_version is None else library + "==" + library_version
              # Check if the package  exists 
              max_version = 'x'
              max_version_and_lib = library + "==" + str(max_version)

              # make the layer name readable and consistent of an ARN and for S3
              library_and_version=None
              if library_version is None:
                  library_and_version=max_version_and_lib.replace('==','-')
              else:
                  library_and_version=library_install.replace('==','-')
              
              layer_name =  (library_and_version + '-' + run_time_dash + '-' + machine[0:3]).replace('.','-')

              # # Then check if Layer exists in the account already
              layer_exists = check_if_layer_exists(layer_name)
              # if layer exists return the Layer ARN
              if layer_exists:
                  return layer_exists
              # if layer doesn't exist the run the process of making a new layer
              # Make sure the dir is empty
              run(["rm" , "-rf", "/tmp/*"])
              # Prepare the dir 
              run(["mkdir" ,"/tmp/python" ])
              # Install the new libraries
              outcome = run(["python" , "-m" , "pip" , "install" , library_install  , "-t", "/tmp/python"], check=False, capture_output=True,text=True)
              # print logs
              print(f"returncode = {outcome.returncode}")
              print(f"output: \n {outcome.stdout}")
              
              # Calculate layer limit
              dir_size = run(["du" , "-sh", "/tmp/python"], capture_output=True, text=True)
              dir_size = dir_size.stdout.split()[0]
              dir_size = dir_size.split("M")[0]
              dir_size = dir_size if len(dir_size.split("K"))<2 else float(dir_size.split("K")[0])/1000
              
              if int(float(dir_size)) >= 250:
                  raise ValueError( "Couldn't run. Layer size is over limit.") 

              # Zip the installed libraries
              zip_directory("/tmp/python/" , "/tmp/python.zip")

              # Upload the library into S3
              try:
                  Bucket.upload_file("/tmp/python.zip", "layers_repository/" + layer_name + ".zip")
              except Exception as e:
                  raise e
              # Create a new layer
              try:
                  new_layer = Lambda.publish_layer_version(LayerName= layer_name,
                                                              Content= {
                                                                  'S3Bucket': 'easy-layers-dev-${AWS::Region}',
                                                                  'S3Key':  "layers_repository/" + layer_name + ".zip"},
                                                              CompatibleRuntimes=[run_time],
                                                              CompatibleArchitectures=[machine])
              except Exception as e:
                  raise e
              # Return layer version ARN
              return new_layer["LayerVersionArn"]

          def check_if_layer_exists(layer_name):
              try:
                  list_layer_version = Lambda.list_layer_versions(LayerName=layer_name)["LayerVersions"][0]["LayerVersionArn"]
                  return list_layer_version
              except Exception:
                  pass
              
          def zip_directory(folder_path, zip_path):
              with ZipFile(zip_path, mode='w') as zipf:
                  len_dir_path = len(folder_path)
                  for root, _, files in os.walk(folder_path):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, 'python/'+file_path[len_dir_path:])
      FunctionName: create_needed_layers_310x86
      Handler: index.lambda_handler
      Runtime: python3.10
      Architectures: 
        - x86_64
      Description: Creates Needed Layers For Python 3.10 x86
      Timeout: 300
      Role: !GetAtt NeededLayersLambdaRole.Arn
  
  # create all the needed layers
  CreateNeededLayer39arm:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import sys 
          import os
          import shutil
          import boto3
          from subprocess import run,CalledProcessError
          import urllib.request
          from zipfile import ZipFile
          import platform
          import cfnresponse

          try:
              from packaging.version import parse
          except ImportError:
              from pip._vendor.packaging.version import parse
              
          S3 = boto3.resource('s3')
          Bucket = S3.Bucket('easy-layers-dev-${AWS::Region}')
          Lambda = boto3.client('lambda')

          def lambda_handler(event, context):
              # Test Access permision to S3
              try:
                  Bucket.objects.limit(count=1)
              except Exception:
                  return "This function has no access to this bucker or its not exists, please validate"
              # Test access to lambda resources
              try:
                  Lambda.list_functions()
              except Exception:
                  return "This function has no access to Lambda resources, please validate"
              # Create a new layer
              result = {} 
              for library in ['jsonschema','requests','stripe']:
                  new_library_arn = create_new(library , Bucket, Lambda)
                  result[library] = new_library_arn
                  print(new_library_arn)
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, result)
              return result

          def create_new(library, Bucket, Lambda):
              # Extract parameters from API
              library_version = None

              machine = 'arm64' if platform.machine() == 'aarch64' else platform.machine()
              run_time = 'python' + '.'.join(sys.version.split(' ')[0].split('.')[0:2])
              run_time_dash = 'py' + ''.join(sys.version.split(' ')[0].split('.')[0:2]) 

              
              # get the library name and if it has versions make it like such requests==2.28.1
              library_install = library if library_version is None else library + "==" + library_version
              # Check if the package  exists 
              max_version = 'x'
              max_version_and_lib = library + "==" + str(max_version)

              # make the layer name readable and consistent of an ARN and for S3
              library_and_version=None
              if library_version is None:
                  library_and_version=max_version_and_lib.replace('==','-')
              else:
                  library_and_version=library_install.replace('==','-')
              
              layer_name =  (library_and_version + '-' + run_time_dash + '-' + machine[0:3]).replace('.','-')

              # # Then check if Layer exists in the account already
              layer_exists = check_if_layer_exists(layer_name)
              # if layer exists return the Layer ARN
              if layer_exists:
                  return layer_exists
              # if layer doesn't exist the run the process of making a new layer
              # Make sure the dir is empty
              run(["rm" , "-rf", "/tmp/*"])
              # Prepare the dir 
              run(["mkdir" ,"/tmp/python" ])
              # Install the new libraries
              outcome = run(["python" , "-m" , "pip" , "install" , library_install  , "-t", "/tmp/python"], check=False, capture_output=True,text=True)
              # print logs
              print(f"returncode = {outcome.returncode}")
              print(f"output: \n {outcome.stdout}")
              
              # Calculate layer limit
              dir_size = run(["du" , "-sh", "/tmp/python"], capture_output=True, text=True)
              dir_size = dir_size.stdout.split()[0]
              dir_size = dir_size.split("M")[0]
              dir_size = dir_size if len(dir_size.split("K"))<2 else float(dir_size.split("K")[0])/1000
              
              if int(float(dir_size)) >= 250:
                  raise ValueError( "Couldn't run. Layer size is over limit.") 

              # Zip the installed libraries
              zip_directory("/tmp/python/" , "/tmp/python.zip")

              # Upload the library into S3
              try:
                  Bucket.upload_file("/tmp/python.zip", "layers_repository/" + layer_name + ".zip")
              except Exception as e:
                  raise e
              # Create a new layer
              try:
                  new_layer = Lambda.publish_layer_version(LayerName= layer_name,
                                                              Content= {
                                                                  'S3Bucket': 'easy-layers-dev-${AWS::Region}',
                                                                  'S3Key':  "layers_repository/" + layer_name + ".zip"},
                                                              CompatibleRuntimes=[run_time],
                                                              CompatibleArchitectures=[machine])
              except Exception as e:
                  raise e
              # Return layer version ARN
              return new_layer["LayerVersionArn"]

          def check_if_layer_exists(layer_name):
              try:
                  list_layer_version = Lambda.list_layer_versions(LayerName=layer_name)["LayerVersions"][0]["LayerVersionArn"]
                  return list_layer_version
              except Exception:
                  pass
              
          def zip_directory(folder_path, zip_path):
              with ZipFile(zip_path, mode='w') as zipf:
                  len_dir_path = len(folder_path)
                  for root, _, files in os.walk(folder_path):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, 'python/'+file_path[len_dir_path:])
      FunctionName: create_needed_layers_39arm
      Handler: index.lambda_handler
      Runtime: python3.9
      Architectures: 
        - arm64
      Description: Creates Needed Layers For Python 3.9 ARM
      Timeout: 300
      Role: !GetAtt NeededLayersLambdaRole.Arn

  CreateNeededLayer39x86:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import sys 
          import os
          import shutil
          import boto3
          from subprocess import run,CalledProcessError
          import urllib.request
          from zipfile import ZipFile
          import platform
          import cfnresponse

          try:
              from packaging.version import parse
          except ImportError:
              from pip._vendor.packaging.version import parse
              
          S3 = boto3.resource('s3')
          Bucket = S3.Bucket('easy-layers-dev-${AWS::Region}')
          Lambda = boto3.client('lambda')

          def lambda_handler(event, context):
              # Test Access permision to S3
              try:
                  Bucket.objects.limit(count=1)
              except Exception:
                  return "This function has no access to this bucker or its not exists, please validate"
              # Test access to lambda resources
              try:
                  Lambda.list_functions()
              except Exception:
                  return "This function has no access to Lambda resources, please validate"
              # Create a new layer
              result = {} 
              for library in ['jsonschema','requests','stripe']:
                  new_library_arn = create_new(library , Bucket, Lambda)
                  result[library] = new_library_arn
                  print(new_library_arn)
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, result)
              return result

          def create_new(library, Bucket, Lambda):
              # Extract parameters from API
              library_version = None

              machine = 'arm64' if platform.machine() == 'aarch64' else platform.machine()
              run_time = 'python' + '.'.join(sys.version.split(' ')[0].split('.')[0:2])
              run_time_dash = 'py' + ''.join(sys.version.split(' ')[0].split('.')[0:2]) 

              
              # get the library name and if it has versions make it like such requests==2.28.1
              library_install = library if library_version is None else library + "==" + library_version
              # Check if the package  exists 
              max_version = 'x'
              max_version_and_lib = library + "==" + str(max_version)

              # make the layer name readable and consistent of an ARN and for S3
              library_and_version=None
              if library_version is None:
                  library_and_version=max_version_and_lib.replace('==','-')
              else:
                  library_and_version=library_install.replace('==','-')
              
              layer_name =  (library_and_version + '-' + run_time_dash + '-' + machine[0:3]).replace('.','-')

              # # Then check if Layer exists in the account already
              layer_exists = check_if_layer_exists(layer_name)
              # if layer exists return the Layer ARN
              if layer_exists:
                  return layer_exists
              # if layer doesn't exist the run the process of making a new layer
              # Make sure the dir is empty
              run(["rm" , "-rf", "/tmp/*"])
              # Prepare the dir 
              run(["mkdir" ,"/tmp/python" ])
              # Install the new libraries
              outcome = run(["python" , "-m" , "pip" , "install" , library_install  , "-t", "/tmp/python"], check=False, capture_output=True,text=True)
              # print logs
              print(f"returncode = {outcome.returncode}")
              print(f"output: \n {outcome.stdout}")
              
              # Calculate layer limit
              dir_size = run(["du" , "-sh", "/tmp/python"], capture_output=True, text=True)
              dir_size = dir_size.stdout.split()[0]
              dir_size = dir_size.split("M")[0]
              dir_size = dir_size if len(dir_size.split("K"))<2 else float(dir_size.split("K")[0])/1000
              
              if int(float(dir_size)) >= 250:
                  raise ValueError( "Couldn't run. Layer size is over limit.") 

              # Zip the installed libraries
              zip_directory("/tmp/python/" , "/tmp/python.zip")

              # Upload the library into S3
              try:
                  Bucket.upload_file("/tmp/python.zip", "layers_repository/" + layer_name + ".zip")
              except Exception as e:
                  raise e
              # Create a new layer
              try:
                  new_layer = Lambda.publish_layer_version(LayerName= layer_name,
                                                              Content= {
                                                                  'S3Bucket': 'easy-layers-dev-${AWS::Region}',
                                                                  'S3Key':  "layers_repository/" + layer_name + ".zip"},
                                                              CompatibleRuntimes=[run_time],
                                                              CompatibleArchitectures=[machine])
              except Exception as e:
                  raise e
              # Return layer version ARN
              return new_layer["LayerVersionArn"]

          def check_if_layer_exists(layer_name):
              try:
                  list_layer_version = Lambda.list_layer_versions(LayerName=layer_name)["LayerVersions"][0]["LayerVersionArn"]
                  return list_layer_version
              except Exception:
                  pass
              
          def zip_directory(folder_path, zip_path):
              with ZipFile(zip_path, mode='w') as zipf:
                  len_dir_path = len(folder_path)
                  for root, _, files in os.walk(folder_path):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, 'python/'+file_path[len_dir_path:])
      FunctionName: create_needed_layers_39x86
      Handler: index.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Creates Needed Layers For Python 3.9 x86
      Timeout: 300
      Role: !GetAtt NeededLayersLambdaRole.Arn

  CreateNeededLayer38arm:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import sys 
          import os
          import shutil
          import boto3
          from subprocess import run,CalledProcessError
          import urllib.request
          from zipfile import ZipFile
          import platform
          import cfnresponse

          try:
              from packaging.version import parse
          except ImportError:
              from pip._vendor.packaging.version import parse
              
          S3 = boto3.resource('s3')
          Bucket = S3.Bucket('easy-layers-dev-${AWS::Region}')
          Lambda = boto3.client('lambda')

          def lambda_handler(event, context):
              # Test Access permision to S3
              try:
                  Bucket.objects.limit(count=1)
              except Exception:
                  return "This function has no access to this bucker or its not exists, please validate"
              # Test access to lambda resources
              try:
                  Lambda.list_functions()
              except Exception:
                  return "This function has no access to Lambda resources, please validate"
              # Create a new layer
              result = {} 
              for library in ['jsonschema','requests','stripe']:
                  new_library_arn = create_new(library , Bucket, Lambda)
                  result[library] = new_library_arn
                  print(new_library_arn)
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, result)
              return result

          def create_new(library, Bucket, Lambda):
              # Extract parameters from API
              library_version = None

              machine = 'arm64' if platform.machine() == 'aarch64' else platform.machine()
              run_time = 'python' + '.'.join(sys.version.split(' ')[0].split('.')[0:2])
              run_time_dash = 'py' + ''.join(sys.version.split(' ')[0].split('.')[0:2]) 

              
              # get the library name and if it has versions make it like such requests==2.28.1
              library_install = library if library_version is None else library + "==" + library_version
              # Check if the package  exists 
              max_version = 'x'
              max_version_and_lib = library + "==" + str(max_version)

              # make the layer name readable and consistent of an ARN and for S3
              library_and_version=None
              if library_version is None:
                  library_and_version=max_version_and_lib.replace('==','-')
              else:
                  library_and_version=library_install.replace('==','-')
              
              layer_name =  (library_and_version + '-' + run_time_dash + '-' + machine[0:3]).replace('.','-')

              # # Then check if Layer exists in the account already
              layer_exists = check_if_layer_exists(layer_name)
              # if layer exists return the Layer ARN
              if layer_exists:
                  return layer_exists
              # if layer doesn't exist the run the process of making a new layer
              # Make sure the dir is empty
              run(["rm" , "-rf", "/tmp/*"])
              # Prepare the dir 
              run(["mkdir" ,"/tmp/python" ])
              # Install the new libraries
              outcome = run(["python" , "-m" , "pip" , "install" , library_install  , "-t", "/tmp/python"], check=False, capture_output=True,text=True)
              # print logs
              print(f"returncode = {outcome.returncode}")
              print(f"output: \n {outcome.stdout}")
              
              # Calculate layer limit
              dir_size = run(["du" , "-sh", "/tmp/python"], capture_output=True, text=True)
              dir_size = dir_size.stdout.split()[0]
              dir_size = dir_size.split("M")[0]
              dir_size = dir_size if len(dir_size.split("K"))<2 else float(dir_size.split("K")[0])/1000
              
              if int(float(dir_size)) >= 250:
                  raise ValueError( "Couldn't run. Layer size is over limit.") 

              # Zip the installed libraries
              zip_directory("/tmp/python/" , "/tmp/python.zip")

              # Upload the library into S3
              try:
                  Bucket.upload_file("/tmp/python.zip", "layers_repository/" + layer_name + ".zip")
              except Exception as e:
                  raise e
              # Create a new layer
              try:
                  new_layer = Lambda.publish_layer_version(LayerName= layer_name,
                                                              Content= {
                                                                  'S3Bucket': 'easy-layers-dev-${AWS::Region}',
                                                                  'S3Key':  "layers_repository/" + layer_name + ".zip"},
                                                              CompatibleRuntimes=[run_time],
                                                              CompatibleArchitectures=[machine])
              except Exception as e:
                  raise e
              # Return layer version ARN
              return new_layer["LayerVersionArn"]

          def check_if_layer_exists(layer_name):
              try:
                  list_layer_version = Lambda.list_layer_versions(LayerName=layer_name)["LayerVersions"][0]["LayerVersionArn"]
                  return list_layer_version
              except Exception:
                  pass
              
          def zip_directory(folder_path, zip_path):
              with ZipFile(zip_path, mode='w') as zipf:
                  len_dir_path = len(folder_path)
                  for root, _, files in os.walk(folder_path):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, 'python/'+file_path[len_dir_path:])
      FunctionName: create_needed_layers_38arm
      Handler: index.lambda_handler
      Runtime: python3.8
      Architectures: 
        - arm64
      Description: Creates Needed Layers For Python 3.8 ARM
      Timeout: 300
      Role: !GetAtt NeededLayersLambdaRole.Arn

  CreateNeededLayer38x86:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: !Sub |
          import json
          import sys 
          import os
          import shutil
          import boto3
          from subprocess import run,CalledProcessError
          import urllib.request
          from zipfile import ZipFile
          import platform
          import cfnresponse

          try:
              from packaging.version import parse
          except ImportError:
              from pip._vendor.packaging.version import parse
              
          S3 = boto3.resource('s3')
          Bucket = S3.Bucket('easy-layers-dev-${AWS::Region}')
          Lambda = boto3.client('lambda')

          def lambda_handler(event, context):
              # Test Access permision to S3
              try:
                  Bucket.objects.limit(count=1)
              except Exception:
                  return "This function has no access to this bucker or its not exists, please validate"
              # Test access to lambda resources
              try:
                  Lambda.list_functions()
              except Exception:
                  return "This function has no access to Lambda resources, please validate"
              # Create a new layer
              result = {} 
              for library in ['jsonschema','requests', 'stripe']:
                  new_library_arn = create_new(library , Bucket, Lambda)
                  result[library] = new_library_arn
                  print(new_library_arn)
              
              cfnresponse.send(event, context, cfnresponse.SUCCESS, result)
              return result

          def create_new(library, Bucket, Lambda):
              # Extract parameters from API
              library_version = None

              machine = 'arm64' if platform.machine() == 'aarch64' else platform.machine()
              run_time = 'python' + '.'.join(sys.version.split(' ')[0].split('.')[0:2])
              run_time_dash = 'py' + ''.join(sys.version.split(' ')[0].split('.')[0:2]) 

              
              # get the library name and if it has versions make it like such requests==2.28.1
              library_install = library if library_version is None else library + "==" + library_version
              # Check if the package  exists 
              max_version = 'x'
              max_version_and_lib = library + "==" + str(max_version)

              # make the layer name readable and consistent of an ARN and for S3
              library_and_version=None
              if library_version is None:
                  library_and_version=max_version_and_lib.replace('==','-')
              else:
                  library_and_version=library_install.replace('==','-')
              
              layer_name =  (library_and_version + '-' + run_time_dash + '-' + machine[0:3]).replace('.','-')

              # # Then check if Layer exists in the account already
              layer_exists = check_if_layer_exists(layer_name)
              # if layer exists return the Layer ARN
              if layer_exists:
                  return layer_exists
              # if layer doesn't exist the run the process of making a new layer
              # Make sure the dir is empty
              run(["rm" , "-rf", "/tmp/*"])
              # Prepare the dir 
              run(["mkdir" ,"/tmp/python" ])
              # Install the new libraries
              outcome = run(["python" , "-m" , "pip" , "install" , library_install  , "-t", "/tmp/python"], check=False, capture_output=True,text=True)
              # print logs
              print(f"returncode = {outcome.returncode}")
              print(f"output: \n {outcome.stdout}")
              
              # Calculate layer limit
              dir_size = run(["du" , "-sh", "/tmp/python"], capture_output=True, text=True)
              dir_size = dir_size.stdout.split()[0]
              dir_size = dir_size.split("M")[0]
              dir_size = dir_size if len(dir_size.split("K"))<2 else float(dir_size.split("K")[0])/1000
              
              if int(float(dir_size)) >= 250:
                  raise ValueError( "Couldn't run. Layer size is over limit.") 

              # Zip the installed libraries
              zip_directory("/tmp/python/" , "/tmp/python.zip")

              # Upload the library into S3
              try:
                  Bucket.upload_file("/tmp/python.zip", "layers_repository/" + layer_name + ".zip")
              except Exception as e:
                  raise e
              # Create a new layer
              try:
                  new_layer = Lambda.publish_layer_version(LayerName= layer_name,
                                                              Content= {
                                                                  'S3Bucket': 'easy-layers-dev-${AWS::Region}',
                                                                  'S3Key':  "layers_repository/" + layer_name + ".zip"},
                                                              CompatibleRuntimes=[run_time],
                                                              CompatibleArchitectures=[machine])
              except Exception as e:
                  raise e
              # Return layer version ARN
              return new_layer["LayerVersionArn"]

          def check_if_layer_exists(layer_name):
              try:
                  list_layer_version = Lambda.list_layer_versions(LayerName=layer_name)["LayerVersions"][0]["LayerVersionArn"]
                  return list_layer_version
              except Exception:
                  pass
              
          def zip_directory(folder_path, zip_path):
              with ZipFile(zip_path, mode='w') as zipf:
                  len_dir_path = len(folder_path)
                  for root, _, files in os.walk(folder_path):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, 'python/'+file_path[len_dir_path:])
      FunctionName: create_needed_layers_38x86
      Handler: index.lambda_handler
      Runtime: python3.8
      Architectures: 
        - x86_64
      Description: Creates Needed Layers For Python 3.8 x86
      Timeout: 300
      Role: !GetAtt NeededLayersLambdaRole.Arn

  TriggerNeededLayersV2310arm:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CreateNeededLayer39arm
    Properties:
      ServiceToken: !GetAtt CreateNeededLayer310arm.Arn

  TriggerNeededLayersV2310x86:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CreateNeededLayer310x86
    Properties:
      ServiceToken: !GetAtt CreateNeededLayer310x86.Arn
      
  TriggerNeededLayersV239arm:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CreateNeededLayer39arm
    Properties:
      ServiceToken: !GetAtt CreateNeededLayer39arm.Arn

  TriggerNeededLayersV239x86:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CreateNeededLayer39x86
    Properties:
      ServiceToken: !GetAtt CreateNeededLayer39x86.Arn

  TriggerNeededLayersV238arm:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CreateNeededLayer38arm
    Properties:
      ServiceToken: !GetAtt CreateNeededLayer38arm.Arn

  TriggerNeededLayersV238x86:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CreateNeededLayer38x86
    Properties:
      ServiceToken: !GetAtt CreateNeededLayer38x86.Arn

  # set up queues for processing functions
  Py310x86SqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-310-x86-sqs-queue
      VisibilityTimeout: 310
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py310x86SqsQueueDead"
            - "Arn"
        maxReceiveCount: 2
  
  Py310x86SqsQueueDead: 
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-310-x86-sqs-queue-dead
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py310x86SqsQueueDeadDead"
            - "Arn"
        maxReceiveCount: 1
  
  Py310x86SqsQueueDeadDead:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-310-x86-sqs-queue-dead-dead
   
  Py310ArmSqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-310-arm-sqs-queue
      VisibilityTimeout: 310
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py310ArmSqsQueueDead"
            - "Arn"
        maxReceiveCount: 2
  
  Py310ArmSqsQueueDead: 
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-310-arm-sqs-queue-dead
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py310ArmSqsQueueDeadDead"
            - "Arn"
        maxReceiveCount: 1
  
  Py310ArmSqsQueueDeadDead:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-310-arm-sqs-queue-dead-dead
      
  Py39x86SqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-39-x86-sqs-queue
      VisibilityTimeout: 310
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py39x86SqsQueueDead"
            - "Arn"
        maxReceiveCount: 2
  
  Py39x86SqsQueueDead: 
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-39-x86-sqs-queue-dead
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py39x86SqsQueueDeadDead"
            - "Arn"
        maxReceiveCount: 1
  
  Py39x86SqsQueueDeadDead:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-39-x86-sqs-queue-dead-dead 

  Py38x86SqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-38-x86-sqs-queue
      VisibilityTimeout: 310
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py38x86SqsQueueDead"
            - "Arn"
        maxReceiveCount: 2
  
  Py38x86SqsQueueDead: 
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-38-x86-sqs-queue-dead
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py38x86SqsQueueDeadDead"
            - "Arn"
        maxReceiveCount: 1
  
  Py38x86SqsQueueDeadDead:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-38-x86-sqs-queue-dead-dead 

  Py39ArmSqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-39-arm-sqs-queue
      VisibilityTimeout: 310
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py39ArmSqsQueueDead"
            - "Arn"
        maxReceiveCount: 2
  
  Py39ArmSqsQueueDead: 
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-39-arm-sqs-queue-dead
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py39ArmSqsQueueDeadDead"
            - "Arn"
        maxReceiveCount: 1
  
  Py39ArmSqsQueueDeadDead:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-39-arm-sqs-queue-dead-dead 

  Py38ArmSqsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-38-arm-sqs-queue
      VisibilityTimeout: 310
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py38ArmSqsQueueDead"
            - "Arn"
        maxReceiveCount: 2
  
  Py38ArmSqsQueueDead: 
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-38-arm-sqs-queue-dead
      RedrivePolicy: 
        deadLetterTargetArn: 
          Fn::GetAtt: 
            - "Py38ArmSqsQueueDeadDead"
            - "Arn"
        maxReceiveCount: 1
  
  Py38ArmSqsQueueDeadDead:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: py-38-arm-sqs-queue-dead-dead 

  # set up the lambda functions that relay api invocations to queue
  SendToQueue310x86:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV2310x86
    Properties:
      CodeUri: src/
      FunctionName: send_to_queue_310x86
      Handler: send_to_queue.lambda_handler
      Runtime: python3.10
      Architectures: 
        - x86_64
      Description: Checks If A Layer Exists When Someone Submits Python 3.10 x86 And Sends To Queue
      Timeout: 30
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /create_layer310x86
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV2310x86.jsonschema
        - !GetAtt TriggerNeededLayersV2310x86.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
              - lambda:GetLayerVersion
            Resource: "*"
          - Sid: VisualEditor5
            Effect: Allow
            Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource: "*"
            
  SendToQueue39x86:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV239x86
    Properties:
      CodeUri: src/
      FunctionName: send_to_queue_39x86
      Handler: send_to_queue.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Checks If A Layer Exists When Someone Submits Python 3.9 x86 And Sends To Queue
      Timeout: 30
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /create_layer39x86
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV239x86.jsonschema
        - !GetAtt TriggerNeededLayersV239x86.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
              - lambda:GetLayerVersion
            Resource: "*"
          - Sid: VisualEditor5
            Effect: Allow
            Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource: "*"
  # define the Lambda function and its code
  SendToQueue38x86:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV238x86
    Properties:
      CodeUri: src/
      FunctionName: send_to_queue_38x86
      Handler: send_to_queue.lambda_handler
      Runtime: python3.8
      Architectures: 
        - x86_64
      Description: Checks If A Layer Exists When Someone Submits Python 3.8 x86 And Sends To Queue
      Timeout: 30
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /create_layer38x86
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV238x86.jsonschema
        - !GetAtt TriggerNeededLayersV238x86.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
              - lambda:GetLayerVersion
            Resource: "*"
          - Sid: VisualEditor5
            Effect: Allow
            Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource: "*"
  # define the Lambda function and its code
  SendToQueue310arm:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV2310arm
    Properties:
      CodeUri: src/
      FunctionName: send_to_queue_310arm
      Handler: send_to_queue.lambda_handler
      Runtime: python3.10
      Architectures: 
        - arm64
      Description: Checks If A Layer Exists When Someone Submits Python 3.10 arm And Sends To Queue
      Timeout: 30
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /create_layer310arm
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV2310arm.jsonschema
        - !GetAtt TriggerNeededLayersV2310arm.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
              - lambda:GetLayerVersion
            Resource: "*"
          - Sid: VisualEditor5
            Effect: Allow
            Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource: "*"
  
  SendToQueue39arm:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV239arm
    Properties:
      CodeUri: src/
      FunctionName: send_to_queue_39arm
      Handler: send_to_queue.lambda_handler
      Runtime: python3.9
      Architectures: 
        - arm64
      Description: Checks If A Layer Exists When Someone Submits Python 3.9 arm And Sends To Queue
      Timeout: 30
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /create_layer39arm
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV239arm.jsonschema
        - !GetAtt TriggerNeededLayersV239arm.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
              - lambda:GetLayerVersion
            Resource: "*"
          - Sid: VisualEditor5
            Effect: Allow
            Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource: "*"
  # send to queue 38 arm
  SendToQueue38arm:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV238arm
    Properties:
      CodeUri: src/
      FunctionName: send_to_queue_38arm
      Handler: send_to_queue.lambda_handler
      Runtime: python3.8
      Architectures: 
        - arm64
      Description: Checks If A Layer Exists When Someone Submits Python 3.8 arm And Sends To Queue
      Timeout: 30
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /create_layer38arm
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV238arm.jsonschema
        - !GetAtt TriggerNeededLayersV238arm.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
              - lambda:GetLayerVersion
            Resource: "*"
          - Sid: VisualEditor5
            Effect: Allow
            Action:
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource: "*"

  # define the Lambda functions that create layers and its code
  CreateLayer310x86:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV2310x86
    Properties:
      CodeUri: src/
      FunctionName: create_layer_easy_layers_310x86
      Handler: create_layer.lambda_handler
      Runtime: python3.10
      Architectures: 
        - x86_64
      Description: Creates & Checks If A Layer Exists When Someone Submits Python 3.10 x86
      Timeout: 300
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt Py310x86SqsQueue.Arn
            BatchSize: 1
      Layers:
        - !GetAtt TriggerNeededLayersV2310x86.jsonschema
        - !GetAtt TriggerNeededLayersV2310x86.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - lambda:GetLayerVersion
              - lambda:DeleteLayerVersion
              - lambda:AddLayerVersionPermission
            Resource: "*"
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObjectAcl
              - s3:GetObject
              - logs:CreateLogStream
              - lambda:PublishLayerVersion
              - s3:ListBucket
              - logs:PutLogEvents
            Resource:
              - "*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - execute-api:Invoke
              - execute-api:ManageConnections
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource:
              - "*"
              
  CreateLayer39x86:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV239x86
    Properties:
      CodeUri: src/
      FunctionName: create_layer_easy_layers_39x86
      Handler: create_layer.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Creates & Checks If A Layer Exists When Someone Submits Python 3.9 x86
      Timeout: 300
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt Py39x86SqsQueue.Arn
            BatchSize: 1
      Layers:
        - !GetAtt TriggerNeededLayersV239x86.jsonschema
        - !GetAtt TriggerNeededLayersV239x86.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - lambda:GetLayerVersion
              - lambda:DeleteLayerVersion
              - lambda:AddLayerVersionPermission
            Resource: "*"
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObjectAcl
              - s3:GetObject
              - logs:CreateLogStream
              - lambda:PublishLayerVersion
              - s3:ListBucket
              - logs:PutLogEvents
            Resource:
              - "*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - execute-api:Invoke
              - execute-api:ManageConnections
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource:
              - "*"
  # define the Lambda function and its code
  CreateLayer38x86:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV238x86
    Properties:
      CodeUri: src/
      FunctionName: create_layer_easy_layers_38x86
      Handler: create_layer.lambda_handler
      Runtime: python3.8
      Architectures: 
        - x86_64
      Description: Creates & Checks If A Layer Exists When Someone Submits Python 3.8 x86
      Timeout: 300
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt Py38x86SqsQueue.Arn
            BatchSize: 1
      Layers:
        - !GetAtt TriggerNeededLayersV238x86.jsonschema
        - !GetAtt TriggerNeededLayersV238x86.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - lambda:GetLayerVersion
              - lambda:DeleteLayerVersion
              - lambda:AddLayerVersionPermission
            Resource: "*"
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObjectAcl
              - s3:GetObject
              - logs:CreateLogStream
              - lambda:PublishLayerVersion
              - s3:ListBucket
              - logs:PutLogEvents
            Resource:
              - "*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - execute-api:Invoke
              - execute-api:ManageConnections
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource:
              - "*"
  # define the Lambda function and its code
  CreateLayer310arm:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV2310arm
    Properties:
      CodeUri: src/
      FunctionName: create_layer_easy_layers_310arm
      Handler: create_layer.lambda_handler
      Runtime: python3.10
      Architectures: 
        - arm64
      Description: Creates & Checks If A Layer Exists When Someone Submits Python 3.10 arm
      Timeout: 300
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt Py310ArmSqsQueue.Arn
            BatchSize: 1
      Layers:
        - !GetAtt TriggerNeededLayersV2310arm.jsonschema
        - !GetAtt TriggerNeededLayersV2310arm.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - lambda:GetLayerVersion
              - lambda:DeleteLayerVersion
              - lambda:AddLayerVersionPermission
            Resource: "*"
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObjectAcl
              - s3:GetObject
              - logs:CreateLogStream
              - lambda:PublishLayerVersion
              - s3:ListBucket
              - logs:PutLogEvents
            Resource:
              - "*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - execute-api:Invoke
              - execute-api:ManageConnections
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource:
              - "*"
              
  CreateLayer39arm:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV239arm
    Properties:
      CodeUri: src/
      FunctionName: create_layer_easy_layers_39arm
      Handler: create_layer.lambda_handler
      Runtime: python3.9
      Architectures: 
        - arm64
      Description: Creates & Checks If A Layer Exists When Someone Submits Python 3.9 arm
      Timeout: 300
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt Py39ArmSqsQueue.Arn
            BatchSize: 1
      Layers:
        - !GetAtt TriggerNeededLayersV239arm.jsonschema
        - !GetAtt TriggerNeededLayersV239arm.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - lambda:GetLayerVersion
              - lambda:DeleteLayerVersion
              - lambda:AddLayerVersionPermission
            Resource: "*"
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObjectAcl
              - s3:GetObject
              - logs:CreateLogStream
              - lambda:PublishLayerVersion
              - s3:ListBucket
              - logs:PutLogEvents
            Resource:
              - "*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - execute-api:Invoke
              - execute-api:ManageConnections
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource:
              - "*"
  # define the Lambda function and its code
  CreateLayer38arm:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV238arm
    Properties:
      CodeUri: src/
      FunctionName: create_layer_easy_layers_38arm
      Handler: create_layer.lambda_handler
      Runtime: python3.8
      Architectures: 
        - arm64
      Description: Creates & Checks If A Layer Exists When Someone Submits Python 3.8 arm
      Timeout: 300
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt Py38ArmSqsQueue.Arn
            BatchSize: 1
      Layers:
        - !GetAtt TriggerNeededLayersV238arm.jsonschema
        - !GetAtt TriggerNeededLayersV238arm.requests
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - lambda:ListFunctions
              - lambda:ListLayerVersions
              - lambda:ListLayers
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - lambda:GetLayerVersion
              - lambda:DeleteLayerVersion
              - lambda:AddLayerVersionPermission
            Resource: "*"
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetObjectAcl
              - s3:GetObject
              - logs:CreateLogStream
              - lambda:PublishLayerVersion
              - s3:ListBucket
              - logs:PutLogEvents
            Resource:
              - "*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource:
              - "*"
          - Sid: VisualEditor4
            Effect: Allow
            Action:
              - execute-api:Invoke
              - execute-api:ManageConnections
              - dynamodb:BatchGetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:Query
              - dynamodb:GetItem
              - dynamodb:Scan
              - dynamodb:ConditionCheckItem
            Resource:
              - "*"
  GetLayers:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      Handler: get_layers.lambda_handler
      Runtime: python3.9
      FunctionName: get_layers_easy_layers
      Description: Grabs all the layers
      Timeout: 60
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /get_layers
            Method: get 
      Policies:
        - Statement:
            - Sid: VisualEditor0
              Effect: Allow
              Action:
                - lambda:GetLayerVersion
                - lambda:ListLayerVersions
                - lambda:ListLayers
              Resource: "*"
            - Sid: VisualEditor1
              Effect: Allow
              Action:
                - s3:ListBucket
                - logs:CreateLogGroup
                - s3:GetObjectAcl
                - s3:GetObject
              Resource:
                - !Sub "arn:aws:s3:::easy-layers-dev-${AWS::Region}"
                - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
            - Sid: VisualEditor2
              Effect: Allow
              Action:
                - logs:CreateLogStream
                - logs:PutLogEvents
              Resource: 
                - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/easy_layers_get_layers:*"

  
###########

####### Websocket Portion

  ConnectionsTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      TableName: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
      KeySchema:
        - AttributeName: connectionId
          KeyType: HASH
      AttributeDefinitions:
        - AttributeName: connectionId
          AttributeType: S
      ProvisionedThroughput:
        ReadCapacityUnits: 1
        WriteCapacityUnits: 1

  WebSocketApi:
    Type: 'AWS::ApiGatewayV2::Api'
    Properties:
      Name: WebSocketApi
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: $request.body.action

  WebsocketRoute53RecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      Name: !Sub "wss-${AWS::Region}.easylayers.dev"
      Type: A
      HostedZoneId:
        Ref: HOSTEDZONEID
      AliasTarget:
        DNSName: !GetAtt WebSocketDomainName.RegionalDomainName
        EvaluateTargetHealth: false
        HostedZoneId: !GetAtt WebSocketDomainName.RegionalHostedZoneId
  
  WebsocketCertificate: 
    Type: "AWS::CertificateManager::Certificate"
    Properties: 
      DomainName: !Sub "wss-${AWS::Region}.easylayers.dev"
      DomainValidationOptions:
            - DomainName: !Sub "wss-${AWS::Region}.easylayers.dev"
              HostedZoneId:
                Ref: HOSTEDZONEID
      ValidationMethod: DNS

  WebSocketDomainName:
    Type: AWS::ApiGatewayV2::DomainName
    DependsOn: WebsocketCertificate 
    Properties:
      DomainName: !Sub "wss-${AWS::Region}.easylayers.dev"
      DomainNameConfigurations:
        - EndpointType: 'REGIONAL'
          CertificateArn: !Ref WebsocketCertificate 

  WebsocketApiMapping:
    Type: 'AWS::ApiGatewayV2::ApiMapping'
    DependsOn: 
      - WebSocketApi
      - WebSocketDomainName
    Properties:
      DomainName: !Sub "wss-${AWS::Region}.easylayers.dev"
      ApiId: !Ref WebSocketApi
      Stage: !Ref WebSocketStage
  
  WebSocketIntegrationConnect:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebSocketFunctionConnect.Arn}/invocations"
  
  WebSocketRouteConnect:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$connect'
      AuthorizationType: NONE
      Target: !Join [ '/', [ 'integrations', !Ref WebSocketIntegrationConnect ] ]

  WebsocketRouteConnectIntegrationPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt WebSocketFunctionConnect.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Join 
        - ''
        - - 'arn:'
          - !Ref 'AWS::Partition'
          - ':execute-api:'
          - !Ref 'AWS::Region'
          - ':'
          - !Ref 'AWS::AccountId'
          - ':'
          - !Ref WebSocketApi
          - /*/$connect

  WebSocketIntegrationDisconnect:
    Type: 'AWS::ApiGatewayV2::Integration'
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebSocketFunctionDisconnect.Arn}/invocations"
  
  WebSocketRouteDisconnect:
    Type: 'AWS::ApiGatewayV2::Route'
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: '$disconnect'
      AuthorizationType: NONE
      Target: !Join [ '/', [ 'integrations', !Ref WebSocketIntegrationDisconnect ] ]

  WebsocketRouteDisonnectIntegrationPermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt WebSocketFunctionDisconnect.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Join 
        - ''
        - - 'arn:'
          - !Ref 'AWS::Partition'
          - ':execute-api:'
          - !Ref 'AWS::Region'
          - ':'
          - !Ref 'AWS::AccountId'
          - ':'
          - !Ref WebSocketApi
          - /*/$disconnect

  WebSocketDeployment:
    Type: 'AWS::ApiGatewayV2::Deployment'
    DependsOn:
      - WebSocketRouteConnect
      - WebSocketRouteDisconnect
    Properties:
      ApiId: !Ref WebSocketApi

  WebSocketStage:
    Type: 'AWS::ApiGatewayV2::Stage'
    Properties:
      ApiId: !Ref WebSocketApi
      DeploymentId: !Ref WebSocketDeployment
      StageName: prod

  WebSocketFunctionConnect:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      FunctionName: websocketconnect
      Handler: connect.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Adds Websocket Connection To DynamoDB 
      Timeout: 10
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - dynamodb:PutItem
            Resource:
              - "*"

  WebSocketFunctionDisconnect:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      FunctionName: websocketdisconnect
      Handler: disconnect.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Deletes A Websocket Connection To DynamoDB
      Timeout: 10
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Sid: VisualEditor3
            Effect: Allow
            Action:
              - dynamodb:DeleteItem
            Resource:
              - "*"

### Errors tables
  ErrorsTable:
    Type: 'AWS::DynamoDB::Table'
    Properties:
      TableName: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
      AttributeDefinitions:
        - AttributeName: "runtime"
          AttributeType: "S"
        - AttributeName: "library"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "runtime"
          KeyType: "HASH"
        - AttributeName: "library"
          KeyType: "RANGE"
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

  WriteErrorLayers:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      Handler: write_errors.lambda_handler
      Runtime: python3.9
      FunctionName: write_error_layers_easy_layers
      Description: Writes Errors From Creating Layers
      Timeout: 10
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        SQSEvent1:
          Type: SQS
          Properties:
            Queue: !GetAtt Py39x86SqsQueueDead.Arn
            BatchSize: 1
        SQSEvent2:
          Type: SQS
          Properties:
            Queue: !GetAtt Py38x86SqsQueueDead.Arn
            BatchSize: 1
        SQSEvent3:
          Type: SQS
          Properties:
            Queue: !GetAtt Py39ArmSqsQueueDead.Arn
            BatchSize: 1
        SQSEvent4:
          Type: SQS
          Properties:
            Queue: !GetAtt Py38ArmSqsQueueDead.Arn
            BatchSize: 1
      Policies:
        Statement:
          - Sid: VisualEditor0
            Effect: Allow
            Action:
              - sqs:SendMessage
              - sqs:ReceiveMessage
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
            Resource: "*"
          - Sid: VisualEditor1
            Effect: Allow
            Action:
              - dynamodb:PutItem
            Resource:
              - !GetAtt ErrorsTable.Arn 
          - Sid: VisualEditor2
            Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/write_error_layers_easy_layers:*"

  GetErrorLayers:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      Handler: query_errors.lambda_handler
      Runtime: python3.9
      FunctionName: get_error_layers_easy_layers
      Description: Grabs all the layers
      Timeout: 10
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-websocket-connections"
          ERROR_LAYERS_TABLE: !Sub "easy-layers-dev-${AWS::Region}-error-layers"
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}"
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /query_errors
            Method: get
      Policies:
        - Statement:
            - Sid: VisualEditor1
              Effect: Allow
              Action:
                - dynamodb:BatchGetItem
                - dynamodb:GetRecords
                - dynamodb:GetShardIterator
                - dynamodb:Query
                - dynamodb:GetItem
                - dynamodb:Scan
                - dynamodb:ConditionCheckItem
              Resource:
                - !GetAtt ErrorsTable.Arn 
            - Sid: VisualEditor2
              Effect: Allow
              Action:
                - logs:CreateLogStream
                - logs:PutLogEvents
              Resource: 
                - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/get_error_layers_easy_layers:*"

  GenerateZipUrl:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: src/
      FunctionName: generate_pre_signed_zip_url
      Handler: generate_zip.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Generates A PreSigned URL for users to download
      Timeout: 300
      Environment:
        Variables:
          S3_BUCKET: !Sub "easy-layers-dev-${AWS::Region}" 
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /generate_zip
            Method: post
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
          - Effect: Allow
            Action:
              - s3:GetObject
            Resource:
              - "*"


  ProcessStripe:
    Type: AWS::Serverless::Function
    DependsOn: TriggerNeededLayersV239x86
    Properties:
      CodeUri: src/
      FunctionName: process_stripe_payment
      Handler: stripe.lambda_handler
      Runtime: python3.9
      Architectures: 
        - x86_64
      Description: Processes a stripe payment
      Timeout: 300
      Environment:
        Variables:
          API_KEY:
            Ref: STRIPEAPIKEY 
      Events:
        ApiEvent:
          Type: Api
          Properties:
            RestApiId:
              Ref: ApiGatewayBackend
            Path: /donate
            Method: post
      Layers:
        - !GetAtt TriggerNeededLayersV239x86.jsonschema
        - !GetAtt TriggerNeededLayersV239x86.requests
        - !GetAtt TriggerNeededLayersV239x86.stripe
      Policies:
        Statement:
          - Effect: Allow
            Action: 
              - logs:CreateLogGroup
            Resource: 
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
          - Effect: Allow
            Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource:
              - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"
